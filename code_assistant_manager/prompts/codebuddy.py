from pathlib import Path
from typing import Dict, Optional

from .base import BasePromptHandler


class CodebuddyPromptHandler(BasePromptHandler):
    @property
    def tool_name(self) -> str:
        return "codebuddy"

    @property
    def _default_user_prompt_path(self) -> Optional[Path]:
        # CodeBuddy supports a user-level prompt file (handled in get_prompt_file_path)
        return None

    @property
    def _default_project_prompt_filename(self) -> Optional[str]:
        # Project-level CODEBUDDY.md
        return "CODEBUDDY.md"

    """Handler for CodeBuddy prompt files.

    Behavior per request:
    - Check repository for AGENTS.md and CODEBUDDY.md
    - Inspect README.md, CLAUDE.md, .cursor rules, and .github/copilot-instructions.md if present
    - Create CODEBUDDY.md with commands and high-level architecture if no AGENTS.md exists
    """

    def get_prompt_file_path(
        self, level: str, project_dir: Optional[Path] = None
    ) -> Optional[Path]:
        # CodeBuddy supports a user-level global file ~/.codebuddy/CODEBUDDY.md and project-level ./CODEBUDDY.md
        if level == "project":
            base = Path(project_dir or Path.cwd())
            return base / "CODEBUDDY.md"
        elif level == "user":
            return Path.home() / ".codebuddy" / "CODEBUDDY.md"
        return None

    def get_live_content(
        self, level: str, project_dir: Optional[Path] = None
    ) -> Optional[str]:
        # Support both user and project level
        file_path = self.get_prompt_file_path(level, project_dir)
        if file_path and file_path.exists():
            return file_path.read_text(encoding="utf-8")

        # Check for AGENTS.md as fallback for project level
        if level == "project":
            base = Path(project_dir or Path.cwd())
        else:
            base = Path.home() / ".codebuddy"

        agents_md = base / "AGENTS.md"
        if agents_md.exists():
            return agents_md.read_text(encoding="utf-8")

        # No prompt files found
        return None

    def sync_prompt(
        self, content: str, level: str, project_dir: Optional[Path] = None
    ) -> None:
        # Support both user and project levels
        if level == "project":
            base = Path(project_dir or Path.cwd())
            codebuddy_md = base / "CODEBUDDY.md"
            agents_md = base / "AGENTS.md"
        elif level == "user":
            base = Path.home() / ".codebuddy"
            codebuddy_md = base / "CODEBUDDY.md"
            agents_md = base / "AGENTS.md"
        else:
            raise ValueError("Invalid level for CodeBuddy: %s" % level)

        # If AGENTS.md exists, do not create CODEBUDDY.md, instead update AGENTS.md if desired
        if agents_md.exists():
            # append a small note with sync marker
            existing = agents_md.read_text(encoding="utf-8")
            marker = "\n\n<!-- cam-synced -->\n"
            if marker.strip() not in existing:
                agents_md.write_text(existing + marker + content, encoding="utf-8")
            else:
                # Replace previous synced block
                agents_md.write_text(existing + "\n" + content, encoding="utf-8")
            return

        # If no AGENTS.md, create or overwrite CODEBUDDY.md
        header = "# CODEBUDDY Repository Context (generated by CAM)\n\n"
        # Ensure parent exists
        codebuddy_md.parent.mkdir(parents=True, exist_ok=True)
        codebuddy_md.write_text(header + content, encoding="utf-8")

    def import_from_live(
        self, level: str, project_dir: Optional[Path] = None
    ) -> Optional[Dict]:
        # Return content and file path if present
        file_path = self.get_prompt_file_path(level, project_dir)
        if level == "project":
            base = Path(project_dir or Path.cwd())
        else:
            base = Path.home() / ".codebuddy"

        agents_md = base / "AGENTS.md"
        if agents_md.exists():
            return {
                "content": agents_md.read_text(encoding="utf-8"),
                "file_path": str(agents_md),
            }
        if file_path and file_path.exists():
            return {
                "content": file_path.read_text(encoding="utf-8"),
                "file_path": str(file_path),
            }

        # No prompt files found
        return None
